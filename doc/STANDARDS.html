<h1 id="standards">Standards</h1>
<p>This document is best viewed through a markdown parser.</p>
<h2 id="coding">Coding</h2>
<p>If in doubt, follow the kernel-style. The main exception being that the<br />open-brace for JavaScript/C# functions should <em>always</em> be on the same line:</p>
<pre><code>function myFunction(param1, param2) {
    myFunctionBody...
}</code></pre>
<ul>
<li><p>TAB indent. That way, I can have 8-width indent, you can have 4-width indent<br /> and gnoobs can have their god-forsaken 2-space indent.</p></li>
<li><p>We aren't measured by lines-of-code, so let's not behave like Java devs.<br /> Opening brace is on SAME line as associated control statement, and<br /> non-independent control statements are on the same line as the preceeding<br /> close-brace:</p>
<p>if (condition) {<br /> someCommand();<br />} else if (otherCondition) {<br /> someOtherCommand();<br />} else {<br /> anotherCommand();<br />}</p>
<p>do {<br /> loopCommand();<br />} while (condition);</p>
<p>for (var i = 0; i &lt; 10; i++) {<br /> loopCommand();<br />}</p></li>
<li><p>More than 4 levels of indentation? You should probably rethink your<br /> design... Pull big anonymous functions out and name/document them, separate<br /> big controller into small services/directives.........</p></li>
<li><p>Line length &gt; 80? Probably fine for JavaScript/C#, but don't exceed 200, and be worried if you exceed 160...</p></li>
<li><p>Unit tests / mocks: Besides ensuring that your code actually works, these<br /> also serve as good demonstrations of how to use your code. A few small tests<br /> that can be kept up to date easily are better than a volume of documentation<br /> that ends up being disorganised and out of date. Want to add a feature to your<br /> code? Why not write the tests for the feature BEFORE writing the code, so that<br /> you can test each module/object/function as you finish coding them? This also<br /> makes it easier for others to help...</p></li>
</ul>
<h2 id="architecture">Architecture</h2>
<h3 id="do-hide-system-features"><em>Do</em> hide system features</h3>
<p>Use abstraction to hide the implementation from<br />the interface so that code is easily portable. A good example is hiding<br />a date-picker via some directive &quot;ng-datepicker&quot; instead of using any<br />specific implementation. The actual implementation of the &quot;ng-datepicker&quot;<br />directive is then free to use the HTML5 date picker, a JQueryUI one, or<br />others - and can be changed easily to use others later, without having to<br />alter all the forms that use the date picker.</p>
<p>Communication to server APIs should be hidden in services where possible,<br />so that if/when APIs change, the front-end code only needs to be updated in one<br />place. This also allows mocking of backends, for test purposes.</p>
<h3 id="do-not-hide-language-features"><em>Do not</em> hide language features</h3>
<p>If your code is asynchronous and uses a promise, return a proper promise; don't<br />hide it behind callback functions. By exposing a promise, callbacks can add<br />their own error handling when needed. By not encapsulating the error-handler<br />totally, we allow the caller to use &quot;on done&quot; handlers which care only when the<br />promise is &quot;done&quot;, regardless of whether it was rejected or not. One example of<br />this is disabling the &quot;New&quot; button on a form (when clicked) until the create<br />operation either completes or fails, in order to prevent double-clicks from<br />creating duplicate items.</p>
<pre><code>/* BAD */
function myAsync(params, onSuccess) {
    myApi.get(params)
        .success(function (result) {
            onSuccess(result);
        })
        .error(function (error) {
            myGlobalErrorHandler(&#39;myAsync&#39;, error);
        });
}

/* GOOD */
function myAsync(params) {
    var future = $q.defer();
    return myApi.get(params)
        .success(function (result) {
            future.resolve(result);
        })
        .error(function (error) {
            myGlobalErrorHandler(&#39;myAsync&#39;, error);
            future.reject(error);
        })
    return future.promise;
}</code></pre>
